<div class="calculator">
    <h2>Schmid Factor Calculator</h2>
    
    <div class="input-group">
        <label>Crystal System:</label>
        <select id="crystalSystem" onchange="updateSlipSystems()">
            <option value="cubic">Cubic</option>
            <option value="hexagonal">Hexagonal</option>
        </select>    
    </div>
    
    <div class="material-select-group">
        <label for="materialSelect">Select Material:</label>
        <select id="materialSelect" onchange="updateMaterialParameters()">
            <option value="">Custom Parameters</option>
            <optgroup label="Cubic Metals (FCC)">
                <option value="Al">Aluminum (Al)</option>
                <option value="Cu">Copper (Cu)</option>
                <option value="Ni">Nickel (Ni)</option>
                <option value="Au">Gold (Au)</option>
                <option value="Ag">Silver (Ag)</option>
                <option value="Pb">Lead (Pb)</option>
            </optgroup>
            <optgroup label="Cubic Metals (BCC)">
                <option value="Fe">Iron (Fe)</option>
                <option value="W">Tungsten (W)</option>
                <option value="Cr">Chromium (Cr)</option>
                <option value="Mo">Molybdenum (Mo)</option>
                <option value="Ta">Tantalum (Ta)</option>
            </optgroup>
            <optgroup label="Hexagonal Metals (HCP)">
                <option value="Ti">Titanium (Ti)</option>
                <option value="Mg">Magnesium (Mg)</option>
                <option value="Zn">Zinc (Zn)</option>
                <option value="Zr">Zirconium (Zr)</option>
                <option value="Co">Cobalt (Co)</option>
                <option value="Be">Beryllium (Be)</option>
            </optgroup>
            <optgroup label="Hexagonal Ceramics">
                <option value="Al2O3">Aluminum Oxide (Al₂O₃)</option>
                <option value="Fe2O3">Iron Oxide (Fe₂O₃)</option>
            </optgroup>
        </select>
    </div>
    
    <div class="input-group">
        <label>Lattice Parameters:</label>
        <div class="input-row">
            <div>
                <label>a (Å):</label>
                <input type="number" id="lattice_a" step="0.001" value="3.615">
            </div>
            <div id="cContainer" style="display: none;">
                <label>c (Å):</label>
                <input type="number" id="lattice_c" step="0.001" value="5.761">
            </div>
        </div>
    </div>
    
    <div class="input-group">
        <label>Loading Direction (Miller Indices):</label>
        <div class="indices-input">
            <div class="index-group">
                <label>h</label>
                <input type="number" id="load_h" value="1">
            </div>
            <div class="index-group">
                <label>k</label>
                <input type="number" id="load_k" value="0">
            </div>
            <div class="index-group" id="load_i_container" style="display: none;">
                <label>i</label>
                <input type="number" id="load_i" value="-1" disabled>
            </div>
            <div class="index-group">
                <label>l</label>
                <input type="number" id="load_l" value="0">
            </div>
        </div>
    </div>
    
    <div class="input-group">
        <label>Applied Stress (MPa):</label>
        <input type="number" id="appliedStress" value="100">
    </div>
    
    <button onclick="calculateSchmidFactors()">Calculate Schmid Factors</button>
    
    <!-- 3D Visualization Section -->
    <div class="visualization-section">
        <h3>Crystal Structure Visualization</h3>
        <div class="visualization-container">
            <div id="crystal-visualization"></div>
            <div class="visualization-controls">
                <button id="resetViewBtn">Reset View</button>
                <div class="toggle-options">
                    <label><input type="checkbox" id="showSlipPlanes" checked> Show Slip Planes</label>
                    <label><input type="checkbox" id="showLoadDirection" checked> Show Loading Direction</label>
                    <label><input type="checkbox" id="showUnitCell" checked> Show Unit Cell</label>
                </div>
            </div>
        </div>
        <div class="visualization-legend">
            <div class="legend-item"><span class="legend-color" style="background-color: #ff0000;"></span> Loading Direction</div>
            <div class="legend-item"><span class="legend-color" style="background-color: #0000ff;"></span> Slip Direction</div>
            <div class="legend-item"><span class="legend-color" style="background-color: rgba(0, 255, 0, 0.3);"></span> Slip Plane</div>
            <div class="legend-item"><span class="legend-color" style="background-color: #cccccc;"></span> Unit Cell</div>
        </div>
    </div>
    
    <div class="results" id="results" style="display: none;">
        <h3>Schmid Factors for <span id="resultDirection"></span> Loading</h3>
        <div class="table-container">
            <table id="schmidTable">
                <thead>
                    <tr>
                        <th>Slip System</th>
                        <th>Slip Plane</th>
                        <th>Slip Direction</th>
                        <th>Schmid Factor</th>
                        <th>CRSS (MPa)</th>
                    </tr>
                </thead>
                <tbody id="schmidTableBody">
                    <!-- Results will be inserted here -->
                </tbody>
            </table>
        </div>
        
        <div id="highestSchmid" class="highlighted-result">
            <!-- Highest Schmid factor result will be shown here -->
        </div>
    </div>
</div>

<style>
.calculator {
    max-width: 800px;
    margin: 20px auto;
    padding: 20px;
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 15px rgba(0,0,0,0.1);
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
}

.input-group {
    margin-bottom: 15px;
}

.input-group label {
    display: block;
    margin-bottom: 5px;
    font-weight: 500;
}

.indices-input {
    display: flex;
    gap: 10px;
    margin-bottom: 10px;
    align-items: flex-end;
}

.index-group {
    display: flex;
    flex-direction: column;
}

.index-group label {
    font-size: 0.8em;
    margin-bottom: 2px;
    color: #666;
}

.input-row {
    display: flex;
    gap: 10px;
    margin-bottom: 10px;
    align-items: flex-end;
}

input[type="number"] {
    width: 80px;
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
}

select {
    width: 200px;
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
}

button {
    background: #0066cc;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 4px;
    cursor: pointer;
    margin-top: 10px;
}

button:hover {
    background: #0052a3;
}

.table-container {
    overflow-x: auto;
    margin: 20px 0;
    background: white;
    border-radius: 4px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.1);
}

table {
    width: 100%;
    border-collapse: collapse;
}

th, td {
    padding: 12px 15px;
    text-align: left;
    border-bottom: 1px solid #ddd;
}

th {
    background-color: #f1f3f5;
    font-weight: 600;
}

tr:hover {
    background-color: #f8f9fa;
}

.highlighted-result {
    margin-top: 20px;
    padding: 15px;
    background-color: #e6f3ff;
    border-left: 4px solid #0066cc;
    border-radius: 4px;
}

.highest-row {
    background-color: #e6f3ff !important;
    font-weight: 500;
}

/* Visualization Styles */
.visualization-section {
    margin: 30px 0;
    border: 1px solid #ddd;
    border-radius: 8px;
    padding: 20px;
    background: #f8f9fa;
}

.visualization-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-bottom: 20px;
}

#crystal-visualization {
    width: 100%;
    height: 400px;
    border-radius: 8px;
    overflow: hidden;
    background-color: #f0f0f0;
    position: relative;
}

.visualization-controls {
    width: 100%;
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 10px;
    flex-wrap: wrap;
}

.toggle-options {
    display: flex;
    gap: 15px;
    flex-wrap: wrap;
}

.toggle-options label {
    display: flex;
    align-items: center;
    font-size: 0.9em;
    cursor: pointer;
}

.toggle-options input[type="checkbox"] {
    margin-right: 5px;
}

.visualization-legend {
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
    margin-top: 10px;
    font-size: 0.9em;
}

.legend-item {
    display: flex;
    align-items: center;
}

.legend-color {
    width: 15px;
    height: 15px;
    border-radius: 3px;
    margin-right: 6px;
    display: inline-block;
}

#resetViewBtn {
    background: #6c757d;
    color: white;
    border: none;
    padding: 5px 10px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.9em;
}

#resetViewBtn:hover {
    background: #5a6268;
}

.category-header {
    background-color: #e9ecef;
    font-weight: bold;
    text-align: center;
    padding: 8px 0;
}

.category-row {
    background-color: #f8f9fa !important;
}

.disclaimer {
    margin-top: 30px;
    padding: 15px;
    background-color: #fff3cd;
    border-left: 4px solid #ffc107;
    border-radius: 4px;
    font-size: 0.9em;
    color: #664d03;
}

tr.highest-row {
    background-color: #e6f3ff !important;
    font-weight: 500;
}

@media (max-width: 768px) {
    .indices-input {
        flex-wrap: wrap;
    }
    
    .input-row {
        flex-wrap: wrap;
    }
}
</style>

<script>
// Material database with crystal structure, lattice parameters, and critical resolved shear stress (CRSS) information
const materialDatabase = {
    // FCC Metals
    'Al': { structure: 'FCC', crss: 7.8, a: 4.046, c: null, system: 'cubic' },
    'Cu': { structure: 'FCC', crss: 10.0, a: 3.615, c: null, system: 'cubic' },
    'Ni': { structure: 'FCC', crss: 15.0, a: 3.524, c: null, system: 'cubic' },
    'Au': { structure: 'FCC', crss: 5.5, a: 4.078, c: null, system: 'cubic' },
    'Ag': { structure: 'FCC', crss: 6.0, a: 4.086, c: null, system: 'cubic' },
    'Pb': { structure: 'FCC', crss: 0.8, a: 4.950, c: null, system: 'cubic' },
    
    // BCC Metals
    'Fe': { structure: 'BCC', crss: 27.0, a: 2.866, c: null, system: 'cubic' },
    'W': { structure: 'BCC', crss: 210.0, a: 3.165, c: null, system: 'cubic' },
    'Cr': { structure: 'BCC', crss: 46.0, a: 2.884, c: null, system: 'cubic' },
    'Mo': { structure: 'BCC', crss: 95.0, a: 3.147, c: null, system: 'cubic' },
    'Ta': { structure: 'BCC', crss: 50.0, a: 3.306, c: null, system: 'cubic' },
    
    // HCP Metals
    'Ti': { structure: 'HCP', crss: 68.0, a: 2.950, c: 4.686, system: 'hexagonal', ca: 1.587 },
    'Mg': { structure: 'HCP', crss: 0.7, a: 3.209, c: 5.211, system: 'hexagonal', ca: 1.624 },
    'Zn': { structure: 'HCP', crss: 2.0, a: 2.665, c: 4.947, system: 'hexagonal', ca: 1.856 },
    'Zr': { structure: 'HCP', crss: 19.0, a: 3.231, c: 5.148, system: 'hexagonal', ca: 1.593 },
    'Co': { structure: 'HCP', crss: 10.0, a: 2.507, c: 4.070, system: 'hexagonal', ca: 1.623 },
    'Be': { structure: 'HCP', crss: 0.7, a: 2.286, c: 3.583, system: 'hexagonal', ca: 1.568 },
    
    // Hexagonal Ceramics
    'Al2O3': { structure: 'HCP', crss: 300.0, a: 4.785, c: 12.991, system: 'hexagonal', ca: 2.715 },
    'Fe2O3': { structure: 'HCP', crss: 210.0, a: 5.038, c: 13.772, system: 'hexagonal', ca: 2.733 }
};

// Slip systems for different crystal structures
const slipSystems = {
    'FCC': {
        planes: [
            [1, 1, 1], [1, 1, 1], [1, 1, 1], 
            [-1, 1, 1], [-1, 1, 1], [-1, 1, 1],
            [1, -1, 1], [1, -1, 1], [1, -1, 1],
            [1, 1, -1], [1, 1, -1], [1, 1, -1]
        ],
        directions: [
            [1, 0, -1], [-1, 1, 0], [0, -1, 1],
            [1, 0, 1], [-1, -1, 0], [0, 1, 1],
            [1, 0, 1], [1, 1, 0], [0, -1, -1],
            [1, 0, -1], [1, -1, 0], [0, 1, -1]
        ],
        names: [
            "(111)[10-1]", "(111)[-110]", "(111)[01-1]",
            "(-111)[101]", "(-111)[-1-10]", "(-111)[011]",
            "(1-11)[101]", "(1-11)[110]", "(1-11)[0-1-1]",
            "(11-1)[10-1]", "(11-1)[1-10]", "(11-1)[01-1]"
        ]
    },
    'BCC': {
        // Primary slip systems: {110}<111>
        planes: [
            [1, 1, 0], [1, 1, 0],
            [-1, 1, 0], [-1, 1, 0],
            [1, 0, 1], [1, 0, 1],
            [-1, 0, 1], [-1, 0, 1],
            [0, 1, 1], [0, 1, 1],
            [0, -1, 1], [0, -1, 1]
        ],
        directions: [
            [1, 1, 1], [-1, 1, 1],
            [1, 1, 1], [1, -1, 1],
            [1, 1, 1], [1, 1, -1],
            [1, 1, 1], [-1, 1, 1],
            [1, 1, 1], [1, -1, 1],
            [1, 1, 1], [1, 1, -1]
        ],
        names: [
            "(110)[111]", "(110)[-111]",
            "(-110)[111]", "(-110)[1-11]",
            "(101)[111]", "(101)[11-1]",
            "(-101)[111]", "(-101)[-111]",
            "(011)[111]", "(011)[1-11]",
            "(0-11)[111]", "(0-11)[11-1]"
        ]
    },
    'HCP': {
        // Basal slip systems: (0001)<11-20>
        basal: {
            planes: [
                [0, 0, 0, 1]
            ],
            directions: [
                [2, -1, -1, 0], [1, 1, -2, 0], [-1, 2, -1, 0]
            ],
            names: [
                "(0001)[2-1-10]", "(0001)[11-20]", "(0001)[-12-10]"
            ]
        },
        // Prismatic slip systems: {10-10}<11-20>
        prismatic: {
            planes: [
                [1, 0, -1, 0], [0, 1, -1, 0], [-1, 1, 0, 0]
            ],
            directions: [
                [2, -1, -1, 0], [1, 1, -2, 0], [-1, 2, -1, 0]
            ],
            names: [
                "(10-10)[2-1-10]", "(01-10)[11-20]", "(-1100)[-12-10]"
            ]
        },
        // Pyramidal <a> slip systems: {10-11}<11-20>
        pyramidal_a: {
            planes: [
                [1, 0, -1, 1], [0, 1, -1, 1], [-1, 1, 0, 1],
                [-1, 0, 1, 1], [0, -1, 1, 1], [1, -1, 0, 1]
            ],
            directions: [
                [2, -1, -1, 0], [1, 1, -2, 0], [-1, 2, -1, 0],
                [-2, 1, 1, 0], [-1, -1, 2, 0], [1, -2, 1, 0]
            ],
            names: [
                "(10-11)[2-1-10]", "(01-11)[11-20]", "(-1101)[-12-10]",
                "(-10-11)[-2110]", "(0-1-11)[-1-120]", "(1-10-1)[1-210]"
            ]
        },
        // Pyramidal <c+a> slip systems: {11-22}<11-23>
        pyramidal_ca: {
            planes: [
                [1, 1, -2, 2], [2, -1, -1, 2], [1, -2, 1, 2],
                [-1, -1, 2, 2], [-2, 1, 1, 2], [-1, 2, -1, 2]
            ],
            directions: [
                [1, 1, -2, 3], [2, -1, -1, 3], [1, -2, 1, 3],
                [-1, -1, 2, 3], [-2, 1, 1, 3], [-1, 2, -1, 3]
            ],
            names: [
                "(11-22)[11-23]", "(2-1-12)[2-1-13]", "(1-212)[1-213]",
                "(-1-122)[-1-123]", "(-2112)[-2113]", "(-12-12)[-12-13]"
            ]
        }
    }
};

function updateMaterialParameters() {
    const materialSelect = document.getElementById('materialSelect');
    const selectedMaterial = materialSelect.value;
    
    if (selectedMaterial && materialDatabase[selectedMaterial]) {
        const material = materialDatabase[selectedMaterial];
        
        // Update crystal system
        document.getElementById('crystalSystem').value = material.system;
        
        // Update lattice parameters
        document.getElementById('lattice_a').value = material.a;
        if (material.c) {
            document.getElementById('lattice_c').value = material.c;
        }
        
        // Update UI based on crystal system
        updateSlipSystems();
    }
}

function updateSlipSystems() {
    const crystalSystem = document.getElementById('crystalSystem').value;
    const cContainer = document.getElementById('cContainer');
    const loadIContainer = document.getElementById('load_i_container');
    
    if (crystalSystem === 'cubic') {
        cContainer.style.display = 'none';
        loadIContainer.style.display = 'none';
    } else if (crystalSystem === 'hexagonal') {
        cContainer.style.display = 'block';
        loadIContainer.style.display = 'block';
        updateLoadingI();
    }
}

function updateLoadingI() {
    const h = parseFloat(document.getElementById('load_h').value) || 0;
    const k = parseFloat(document.getElementById('load_k').value) || 0;
    const i = -(h + k);
    document.getElementById('load_i').value = i;
}

function normalize(vector) {
    let magnitude = 0;
    for (let i = 0; i < vector.length; i++) {
        magnitude += vector[i] * vector[i];
    }
    magnitude = Math.sqrt(magnitude);
    
    if (magnitude === 0) return vector;
    
    return vector.map(v => v / magnitude);
}

function dotProduct(v1, v2) {
    let result = 0;
    const minLength = Math.min(v1.length, v2.length);
    
    for (let i = 0; i < minLength; i++) {
        result += v1[i] * v2[i];
    }
    
    return result;
}

// Calculate Schmid factor for cubic systems
function calculateSchmidFactorCubic(loadDirection, slipPlane, slipDirection) {
    // Normalize vectors
    const normalizedLoad = normalize(loadDirection);
    const normalizedSlipPlane = normalize(slipPlane);
    const normalizedSlipDirection = normalize(slipDirection);
    
    // Calculate cosine of angles
    const cosLambda = Math.abs(dotProduct(normalizedLoad, normalizedSlipDirection));
    const cosPhi = Math.abs(dotProduct(normalizedLoad, normalizedSlipPlane));
    
    // Calculate Schmid factor
    return cosLambda * cosPhi;
}

// Convert Miller-Bravais [hkil] to Miller [uvw] indices
function millerBravaisToMiller(hkil) {
    // For directions: [hkil] -> [uvw] where u = h-i/3, v = k-i/3, w = l
    if (hkil.length === 4 && Math.abs(hkil[0] + hkil[1] + hkil[2]) < 0.0001) {
        // This is a direction
        const u = 2*hkil[0] + hkil[1];
        const v = 2*hkil[1] + hkil[0];
        const w = hkil[3];
        return [u, v, w];
    }
    
    // For planes: (hkil) -> (uvw) where u = h, v = k, w = l
    return [hkil[0], hkil[1], hkil[3]];
}

// Calculate Schmid factor for hexagonal systems
function calculateSchmidFactorHexagonal(loadDirection, slipPlane, slipDirection, a, c) {
    // Convert loading direction from Miller-Bravais [hkil] to Cartesian coordinates
    const loadCart = hexDirectionToCartesian(loadDirection, a, c);
    
    // Convert slip plane from Miller-Bravais (hkil) to Cartesian coordinates
    const planeCart = hexPlaneToCartesian(slipPlane, a, c);
    
    // Convert slip direction from Miller-Bravais [hkil] to Cartesian coordinates
    const directionCart = hexDirectionToCartesian(slipDirection, a, c);
    
    // Normalize vectors
    const normalizedLoad = normalize(loadCart);
    const normalizedPlane = normalize(planeCart);
    const normalizedDirection = normalize(directionCart);
    
    // Calculate cosine of angles
    const cosLambda = Math.abs(dotProduct(normalizedLoad, normalizedDirection));
    const cosPhi = Math.abs(dotProduct(normalizedLoad, normalizedPlane));
    
    // Calculate Schmid factor
    return cosLambda * cosPhi;
}

// Build hexagonal lattice basis vectors in Cartesian coordinates
function getHexLatticeBasis(a, c) {
    const a1 = [a, 0, 0];
    const a2 = [-a / 2, (Math.sqrt(3) / 2) * a, 0];
    const a3 = [-a / 2, (-Math.sqrt(3) / 2) * a, 0];
    const cVec = [0, 0, c];
    return { a1, a2, a3, cVec };
}

// Convert hexagonal Miller-Bravais direction [u v t w] to Cartesian coordinates [x,y,z]
function hexDirectionToCartesian(hkil, a, c) {
    const u = hkil[0];
    const v = hkil[1];
    const t = hkil[2];
    const w = hkil[3];

    const { a1, a2, a3, cVec } = getHexLatticeBasis(a, c);
    return [
        u * a1[0] + v * a2[0] + t * a3[0] + w * cVec[0],
        u * a1[1] + v * a2[1] + t * a3[1] + w * cVec[1],
        u * a1[2] + v * a2[2] + t * a3[2] + w * cVec[2]
    ];
}

// Convert hexagonal plane normal (hkil) to Cartesian coordinates [x,y,z]
function hexPlaneToCartesian(hkil, a, c) {
    const h = hkil[0];
    const k = hkil[1];
    const l = hkil[3];

    const { a1, a2, cVec } = getHexLatticeBasis(a, c);
    const det = a1[0] * (a2[1] * cVec[2] - a2[2] * cVec[1])
        - a1[1] * (a2[0] * cVec[2] - a2[2] * cVec[0])
        + a1[2] * (a2[0] * cVec[1] - a2[1] * cVec[0]);

    const b1 = [
        (a2[1] * cVec[2] - a2[2] * cVec[1]) / det,
        (a2[2] * cVec[0] - a2[0] * cVec[2]) / det,
        (a2[0] * cVec[1] - a2[1] * cVec[0]) / det
    ];
    const b2 = [
        (cVec[1] * a1[2] - cVec[2] * a1[1]) / det,
        (cVec[2] * a1[0] - cVec[0] * a1[2]) / det,
        (cVec[0] * a1[1] - cVec[1] * a1[0]) / det
    ];
    const b3 = [
        (a1[1] * a2[2] - a1[2] * a2[1]) / det,
        (a1[2] * a2[0] - a1[0] * a2[2]) / det,
        (a1[0] * a2[1] - a1[1] * a2[0]) / det
    ];

    const hPrime = 2 * h + k;
    const kPrime = h + 2 * k;

    return [
        hPrime * b1[0] + kPrime * b2[0] + l * b3[0],
        hPrime * b1[1] + kPrime * b2[1] + l * b3[1],
        hPrime * b1[2] + kPrime * b2[2] + l * b3[2]
    ];
}

function calculateSchmidFactors() {
    // Get crystal system
    const crystalSystem = document.getElementById('crystalSystem').value;
    
    // Get loading direction
    const loadH = parseFloat(document.getElementById('load_h').value);
    const loadK = parseFloat(document.getElementById('load_k').value);
    const loadL = parseFloat(document.getElementById('load_l').value);
    let loadDirection;
    
    // Get lattice parameters
    const a = parseFloat(document.getElementById('lattice_a').value);
    const c = parseFloat(document.getElementById('lattice_c').value || a);
    
    // Get applied stress
    const appliedStress = parseFloat(document.getElementById('appliedStress').value);
    
    // Get material and its structure
    const materialSelect = document.getElementById('materialSelect');
    const selectedMaterial = materialSelect.value;
    let structure = 'FCC'; // Default to FCC
    let crss = 10.0; // Default CRSS value
    
    if (selectedMaterial && materialDatabase[selectedMaterial]) {
        structure = materialDatabase[selectedMaterial].structure;
        crss = materialDatabase[selectedMaterial].crss;
    }
    
    // Setup based on crystal system
    if (crystalSystem === 'cubic') {
        loadDirection = [loadH, loadK, loadL];
        
        // Get slip systems for the structure
        const slipPlanes = slipSystems[structure].planes;
        const slipDirections = slipSystems[structure].directions;
        const slipNames = slipSystems[structure].names;
        
        // Calculate Schmid factors for each slip system
        const schmidFactors = [];
        
        for (let i = 0; i < slipPlanes.length; i++) {
            const schmidFactor = calculateSchmidFactorCubic(loadDirection, slipPlanes[i], slipDirections[i]);
            const resolvedShearStress = schmidFactor * appliedStress;
            
            schmidFactors.push({
                index: i,
                name: slipNames[i],
                plane: slipPlanes[i],
                direction: slipDirections[i],
                schmidFactor: schmidFactor,
                rss: resolvedShearStress
            });
        }
        
        // Sort by Schmid factor (highest first)
        schmidFactors.sort((a, b) => b.schmidFactor - a.schmidFactor);
        
        // Display results
        displayResults(schmidFactors, loadDirection, structure, crss, selectedMaterial, crystalSystem);
    } 
    else if (crystalSystem === 'hexagonal') {
        // For hexagonal, we use Miller-Bravais indices [hkil]
        const loadI = -(loadH + loadK);
        loadDirection = [loadH, loadK, loadI, loadL];
        
        // Calculate Schmid factors for different HCP slip systems
        const allSchmidFactors = [];
        
        // Process each HCP slip system category
        const hcpCategories = ['basal', 'prismatic', 'pyramidal_a', 'pyramidal_ca'];
        
        for (const category of hcpCategories) {
            const planes = slipSystems.HCP[category].planes;
            const directions = slipSystems.HCP[category].directions;
            const names = slipSystems.HCP[category].names;
            
            for (let i = 0; i < planes.length; i++) {
                for (let j = 0; j < directions.length; j++) {
                    // Use same plane with all directions for basal
                    if (category === 'basal' && i > 0) continue;
                    
                    // Ensure we're using matching plane/direction pairs for prismatic and pyramidal
                    if ((category === 'prismatic' || category.startsWith('pyramidal')) && i !== j % planes.length) {
                        continue;
                    }
                    
                    const schmidFactor = calculateSchmidFactorHexagonal(loadDirection, planes[i], directions[j], a, c);
                    const resolvedShearStress = schmidFactor * appliedStress;
                    
                    const nameIndex = (category === 'basal') ? j : i;
                    
                    allSchmidFactors.push({
                        category: category,
                        name: names[nameIndex],
                        plane: planes[i],
                        direction: directions[j],
                        schmidFactor: schmidFactor,
                        rss: resolvedShearStress
                    });
                }
            }
        }
        
        // Sort by Schmid factor (highest first)
        allSchmidFactors.sort((a, b) => b.schmidFactor - a.schmidFactor);
        
        // Display results
        displayResults(allSchmidFactors, loadDirection, structure, crss, selectedMaterial, crystalSystem);
    }
}

function displayResults(schmidFactors, loadDirection, structure, crss, material, crystalSystem) {
    const tableBody = document.getElementById('schmidTableBody');
    const highestSchmidDiv = document.getElementById('highestSchmid');
    const resultsDiv = document.getElementById('results');
    const resultDirectionSpan = document.getElementById('resultDirection');
    
    // Clear previous results
    tableBody.innerHTML = '';
    
    // Set direction text based on crystal system
    if (crystalSystem === 'cubic') {
        resultDirectionSpan.textContent = `[${loadDirection.join(',')}]`;
    } else if (crystalSystem === 'hexagonal') {
        resultDirectionSpan.textContent = `[${loadDirection[0]},${loadDirection[1]},${loadDirection[2]},${loadDirection[3]}]`;
    }
    
    // Add material name if selected
    if (material) {
        resultDirectionSpan.textContent += ` for ${material} (${structure})`;
    }
    
    // Add rows to table
    let lastCategory = '';
    
    schmidFactors.forEach((system, index) => {
        const row = document.createElement('tr');
        if (index === 0) row.className = 'highest-row';
        
        // For hexagonal systems, add category headers
        if (crystalSystem === 'hexagonal' && system.category !== lastCategory) {
            const categoryRow = document.createElement('tr');
            categoryRow.className = 'category-row';
            categoryRow.innerHTML = `
                <td colspan="5" class="category-header">
                    ${formatCategoryName(system.category)} Slip Systems
                </td>
            `;
            tableBody.appendChild(categoryRow);
            lastCategory = system.category;
        }
        
        // For cubic systems
        if (crystalSystem === 'cubic') {
            row.innerHTML = `
                <td>${index + 1}</td>
                <td>(${system.plane.join('')})</td>
                <td>[${system.direction.join('')}]</td>
                <td>${system.schmidFactor.toFixed(4)}</td>
                <td>${system.rss.toFixed(2)}</td>
            `;
        } 
        // For hexagonal systems
        else if (crystalSystem === 'hexagonal') {
            row.innerHTML = `
                <td>${index + 1}</td>
                <td>${system.name.split(']')[0]}]</td>
                <td>${system.name.split(']')[1]}</td>
                <td>${system.schmidFactor.toFixed(4)}</td>
                <td>${system.rss.toFixed(2)}</td>
            `;
        }
        
        tableBody.appendChild(row);
    });
    
    // Display highest Schmid factor
    const highest = schmidFactors[0];
    
    if (crystalSystem === 'cubic') {
        highestSchmidDiv.innerHTML = `
            <strong>Highest Schmid Factor:</strong> ${highest.schmidFactor.toFixed(4)} for 
            slip system ${highest.name || `(${highest.plane.join('')})[${highest.direction.join('')}]`}
            <br>
            <strong>Resolved Shear Stress:</strong> ${highest.rss.toFixed(2)} MPa
            ${crss ? `<br><strong>Critical RSS (Material):</strong> ${crss} MPa` : ''}
            ${crss ? `<br><strong>Slip Expected:</strong> ${highest.rss > crss ? 'Yes' : 'No'}` : ''}
        `;
    } else if (crystalSystem === 'hexagonal') {
        highestSchmidDiv.innerHTML = `
            <strong>Highest Schmid Factor:</strong> ${highest.schmidFactor.toFixed(4)} for 
            slip system ${highest.name} (${formatCategoryName(highest.category)})
            <br>
            <strong>Resolved Shear Stress:</strong> ${highest.rss.toFixed(2)} MPa
            ${crss ? `<br><strong>Critical RSS (Material):</strong> ${crss} MPa` : ''}
            ${crss ? `<br><strong>Slip Expected:</strong> ${highest.rss > crss ? 'Yes' : 'No'}` : ''}
        `;
    }
    
    // Show results
    resultsDiv.style.display = 'block';
}

function formatCategoryName(category) {
    switch(category) {
        case 'basal':
            return 'Basal';
        case 'prismatic':
            return 'Prismatic';
        case 'pyramidal_a':
            return 'Pyramidal <a>';
        case 'pyramidal_ca':
            return 'Pyramidal <c+a>';
        default:
            return category;
    }
}

// Get the selected structure (FCC, BCC, HCP)
function getSelectedStructure() {
    const material = document.getElementById('materialSelect').value;
    if (!material) return 'FCC';
    
    if (materialDatabase[material]) {
        return materialDatabase[material].structure;
    }
    
    return 'FCC'; // Default to FCC if not found
}

// Initialize and set up event listeners for the page
document.addEventListener('DOMContentLoaded', function() {
    updateSlipSystems();
    
    // Set up event listeners for input changes
    document.getElementById('load_h').addEventListener('input', function() {
        const crystalSystem = document.getElementById('crystalSystem').value;
        if (crystalSystem === 'hexagonal') {
            updateLoadingI();
        }
        updateVisualization();
    });
    
    document.getElementById('load_k').addEventListener('input', function() {
        const crystalSystem = document.getElementById('crystalSystem').value;
        if (crystalSystem === 'hexagonal') {
            updateLoadingI();
        }
        updateVisualization();
    });
    
    document.getElementById('load_l').addEventListener('input', function() {
        updateVisualization();
    });
    
    document.getElementById('crystalSystem').addEventListener('change', function() {
        initVisualization();
    });
    
    document.getElementById('materialSelect').addEventListener('change', function() {
        updateVisualization();
    });
    
    // Visualization control event listeners
    document.getElementById('showSlipPlanes').addEventListener('change', function() {
        updateVisualization();
    });
    
    document.getElementById('showLoadDirection').addEventListener('change', function() {
        updateVisualization();
    });
    
    document.getElementById('showUnitCell').addEventListener('change', function() {
        updateVisualization();
    });
    
    document.getElementById('resetViewBtn').addEventListener('click', function() {
        resetView();
    });
    
    // Add a disclaimer about CRSS values
    const calculator = document.querySelector('.calculator');
    const disclaimer = document.createElement('div');
    disclaimer.className = 'disclaimer';
    disclaimer.innerHTML = `
        <p><strong>Note:</strong> The Critical Resolved Shear Stress (CRSS) values provided are approximate 
        values for pure, single-crystal metals at room temperature. Actual values may vary significantly 
        depending on material purity, microstructure, testing conditions, and other factors.</p>
    `;
    calculator.appendChild(disclaimer);
    
    // Initialize the 3D visualization
    initVisualization();
});

// Load Three.js from CDN
function loadThreeJS() {
    return new Promise((resolve, reject) => {
        // Check if Three.js is already loaded
        if (window.THREE) {
            resolve();
            return;
        }
        
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
        script.onload = () => {
            // Load OrbitControls after Three.js is loaded
            const controlsScript = document.createElement('script');
            controlsScript.src = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js';
            controlsScript.onload = () => resolve();
            controlsScript.onerror = () => reject(new Error('Failed to load OrbitControls'));
            document.head.appendChild(controlsScript);
        };
        script.onerror = () => reject(new Error('Failed to load Three.js'));
        document.head.appendChild(script);
    });
}

// Global visualization variables
let scene, camera, renderer, controls;
let unitCell, loadDirection, slipPlanes, slipDirections;
let currentCrystalSystem = 'cubic';

// Initialize the 3D visualization
async function initVisualization() {
    try {
        await loadThreeJS();
        
        const container = document.getElementById('crystal-visualization');
        
        // Clear existing content
        while (container.firstChild) {
            container.removeChild(container.firstChild);
        }
        
        // Set up scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);
        
        // Set up camera
        const width = container.clientWidth;
        const height = container.clientHeight;
        camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
        camera.position.z = 5;
        
        // Set up renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(width, height);
        container.appendChild(renderer.domElement);
        
        // Set up controls
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;
        
        // Add lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);
        
        // Create groups for different components
        unitCell = new THREE.Group();
        loadDirection = new THREE.Group();
        slipPlanes = new THREE.Group();
        slipDirections = new THREE.Group();
        
        // Add groups to scene
        scene.add(unitCell);
        scene.add(loadDirection);
        scene.add(slipPlanes);
        scene.add(slipDirections);
        
        // Update the current crystal system
        currentCrystalSystem = document.getElementById('crystalSystem').value;
        
        // Create initial visualization
        updateVisualization();
        
        // Set up animation loop
        animate();
        
        // Handle window resize
        window.addEventListener('resize', onWindowResize);
    } catch (error) {
        console.error('Failed to initialize visualization:', error);
    }
}

// Animation loop
function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
}

// Handle window resize
function onWindowResize() {
    const container = document.getElementById('crystal-visualization');
    const width = container.clientWidth;
    const height = container.clientHeight;
    
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
    renderer.setSize(width, height);
}

// Reset camera view
function resetView() {
    camera.position.set(0, 0, 5);
    camera.lookAt(0, 0, 0);
    controls.reset();
}

// Update the visualization based on current settings
function updateVisualization() {
    if (!scene) return;
    
    // Clear existing visualization
    while (unitCell.children.length > 0) {
        unitCell.remove(unitCell.children[0]);
    }
    
    while (loadDirection.children.length > 0) {
        loadDirection.remove(loadDirection.children[0]);
    }
    
    while (slipPlanes.children.length > 0) {
        slipPlanes.remove(slipPlanes.children[0]);
    }
    
    while (slipDirections.children.length > 0) {
        slipDirections.remove(slipDirections.children[0]);
    }
    
    // Get current settings
    const crystalSystem = document.getElementById('crystalSystem').value;
    const showUnitCell = document.getElementById('showUnitCell').checked;
    const showLoadDirection = document.getElementById('showLoadDirection').checked;
    const showSlipPlanes = document.getElementById('showSlipPlanes').checked;
    
    // Create unit cell based on crystal system
    if (showUnitCell) {
        if (crystalSystem === 'cubic') {
            createCubicUnitCell();
        } else if (crystalSystem === 'hexagonal') {
            createHexagonalUnitCell();
        }
    }
    
    // Create load direction arrow
    if (showLoadDirection) {
        const loadH = parseFloat(document.getElementById('load_h').value) || 0;
        const loadK = parseFloat(document.getElementById('load_k').value) || 0;
        const loadL = parseFloat(document.getElementById('load_l').value) || 0;
        
        if (crystalSystem === 'cubic') {
            createLoadDirectionArrow([loadH, loadK, loadL]);
        } else if (crystalSystem === 'hexagonal') {
            const loadI = -(loadH + loadK);
            createLoadDirectionArrow([loadH, loadK, loadI, loadL], true);
        }
    }
    
    // Draw primary slip system
    if (showSlipPlanes) {
        if (crystalSystem === 'cubic') {
            const structure = getSelectedStructure();
            if (structure === 'FCC') {
                // Draw one FCC slip plane and direction
                drawSlipSystem([1, 1, 1], [1, 0, -1], structure);
            } else if (structure === 'BCC') {
                // Draw one BCC slip plane and direction
                drawSlipSystem([1, 1, 0], [1, 1, 1], structure);
            }
        } else if (crystalSystem === 'hexagonal') {
            // Draw one basal slip plane and direction for HCP
            drawSlipSystem([0, 0, 0, 1], [2, -1, -1, 0], 'HCP', true);
            
            // Also draw one prismatic slip plane
            drawSlipSystem([1, 0, -1, 0], [2, -1, -1, 0], 'HCP', true);
        }
    }
}

// Create a cubic unit cell
function createCubicUnitCell() {
    const size = 2;
    const halfSize = size / 2;
    
    // Edges
    const edges = new THREE.EdgesGeometry(new THREE.BoxGeometry(size, size, size));
    const edgeMaterial = new THREE.LineBasicMaterial({ color: 0xcccccc, linewidth: 2 });
    const edgeSegments = new THREE.LineSegments(edges, edgeMaterial);
    unitCell.add(edgeSegments);
    
    // Add some small spheres at the corners
    const sphereGeometry = new THREE.SphereGeometry(0.06, 16, 16);
    const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 });
    
    const corners = [
        [-halfSize, -halfSize, -halfSize],
        [halfSize, -halfSize, -halfSize],
        [halfSize, halfSize, -halfSize],
        [-halfSize, halfSize, -halfSize],
        [-halfSize, -halfSize, halfSize],
        [halfSize, -halfSize, halfSize],
        [halfSize, halfSize, halfSize],
        [-halfSize, halfSize, halfSize]
    ];
    
    corners.forEach(corner => {
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        sphere.position.set(corner[0], corner[1], corner[2]);
        unitCell.add(sphere);
    });
    
    // Coordinate axes
    createCoordinateAxes();
}

// Create a hexagonal unit cell

function createHexagonalUnitCell() {
    const a = 1.0; // Base size
    const c = 1.633 * a; // Ideal c/a ratio for HCP
    
    // Clear any existing mesh
    while (unitCell.children.length > 0) {
        unitCell.remove(unitCell.children[0]);
    }
    
    // Define the 12 vertices of the hexagonal prism (corners)
    const corners = [];
    for (let i = 0; i < 6; i++) {
        const angle = (i * Math.PI) / 3;
        const x = a * Math.cos(angle);
        const y = a * Math.sin(angle);
        
        // Bottom face
        corners.push([x, y, -c/2]);
        
        // Top face
        corners.push([x, y, c/2]);
    }
    
    // Create edges for the unit cell
    const material = new THREE.LineBasicMaterial({ color: 0xcccccc, linewidth: 2 });
    
    // Bottom face
    for (let i = 0; i < 6; i++) {
        const geometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(...corners[i*2]),
            new THREE.Vector3(...corners[((i+1)%6)*2])
        ]);
        const line = new THREE.Line(geometry, material);
        unitCell.add(line);
    }
    
    // Top face
    for (let i = 0; i < 6; i++) {
        const geometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(...corners[i*2+1]),
            new THREE.Vector3(...corners[((i+1)%6)*2+1])
        ]);
        const line = new THREE.Line(geometry, material);
        unitCell.add(line);
    }
    
    // Vertical edges
    for (let i = 0; i < 6; i++) {
        const geometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(...corners[i*2]),
            new THREE.Vector3(...corners[i*2+1])
        ]);
        const line = new THREE.Line(geometry, material);
        unitCell.add(line);
    }
    
    // Add very small vertices at the corners (not atoms, just visual guides)
    const cornerSphereGeometry = new THREE.SphereGeometry(0.02, 16, 16);
    const cornerMaterial = new THREE.MeshBasicMaterial({ color: 0x999999 });
    
    corners.forEach(corner => {
        const sphere = new THREE.Mesh(cornerSphereGeometry, cornerMaterial);
        sphere.position.set(corner[0], corner[1], corner[2]);
        unitCell.add(sphere);
    });
    
    // Create atom geometry and material
    const atomGeometry = new THREE.SphereGeometry(0.15, 24, 24);
    const atomMaterial = new THREE.MeshPhongMaterial({ 
        color: 0x0088ff,
        specular: 0x444444,
        shininess: 60
    });
    
    // Bond material
    const bondMaterial = new THREE.MeshPhongMaterial({ 
        color: 0x888888, 
        transparent: true,
        opacity: 0.4
    });
    
    // Helper function to create atoms
    function createAtom(position) {
        const atom = new THREE.Mesh(atomGeometry, atomMaterial);
        atom.position.copy(position);
        unitCell.add(atom);
        return atom;
    }
    
    // Helper function to create bonds between atoms
    function createBond(atom1Pos, atom2Pos, radius = 0.05) {
        const direction = new THREE.Vector3().subVectors(atom2Pos, atom1Pos);
        const length = direction.length();
        
        const bondGeometry = new THREE.CylinderGeometry(radius, radius, length, 8);
        const bond = new THREE.Mesh(bondGeometry, bondMaterial);
        
        // Position bond at midpoint
        bond.position.copy(atom1Pos);
        bond.position.lerp(atom2Pos, 0.5);
        
        // Orient bond
        bond.setRotationFromQuaternion(
            new THREE.Quaternion().setFromUnitVectors(
                new THREE.Vector3(0, 1, 0),
                direction.normalize()
            )
        );
        
        unitCell.add(bond);
    }
    
    // Create atoms according to the HCP conventional unit cell as shown in the schematic
    // A layer - bottom (z = -c/2)
    const bottomAtoms = [];
    
    // Corner atoms (6)
    for (let i = 0; i < 6; i++) {
        const angle = (i * Math.PI) / 3;
        const x = a * Math.cos(angle);
        const y = a * Math.sin(angle);
        const pos = new THREE.Vector3(x, y, -c/2);
        bottomAtoms.push(createAtom(pos));
    }
    
    // Center atom (1)
    const bottomCenter = createAtom(new THREE.Vector3(0, 0, -c/2));
    bottomAtoms.push(bottomCenter);
    
    // Middle layer (B layer) - at z = 0
    const middleAtoms = [];
    
    // Middle layer atoms - 3 atoms at positions creating the B-layer
    // These are positioned at 1/3 and 2/3 of the hexagon sides
    for (let i = 0; i < 3; i++) {
        const angle1 = (i * 2 * Math.PI) / 3;
        const angle2 = angle1 + (2 * Math.PI) / 3;
        
        const x1 = (a/2) * Math.cos(angle1);
        const y1 = (a/2) * Math.sin(angle1);
        const pos1 = new THREE.Vector3(x1, y1, 0);
        middleAtoms.push(createAtom(pos1));
        
        const x2 = (a/2) * Math.cos(angle2);
        const y2 = (a/2) * Math.sin(angle2);
        const pos2 = new THREE.Vector3(x2, y2, 0);
        middleAtoms.push(createAtom(pos2));
    }
    
    // A layer - top (z = c/2)
    const topAtoms = [];
    
    // Corner atoms (6)
    for (let i = 0; i < 6; i++) {
        const angle = (i * Math.PI) / 3;
        const x = a * Math.cos(angle);
        const y = a * Math.sin(angle);
        const pos = new THREE.Vector3(x, y, c/2);
        topAtoms.push(createAtom(pos));
    }
    
    // Center atom (1)
    const topCenter = createAtom(new THREE.Vector3(0, 0, c/2));
    topAtoms.push(topCenter);
    
    // Create bonds for better visualization
    // Bonds in bottom layer
    for (let i = 0; i < 6; i++) {
        createBond(bottomAtoms[i].position, bottomAtoms[(i+1)%6].position);
        createBond(bottomAtoms[i].position, bottomCenter.position);
    }
    
    // Bonds in top layer
    for (let i = 0; i < 6; i++) {
        createBond(topAtoms[i].position, topAtoms[(i+1)%6].position);
        createBond(topAtoms[i].position, topCenter.position);
    }
    
    // Bonds connecting layers
    for (let i = 0; i < middleAtoms.length; i++) {
        // Connect to closest atoms in top and bottom layers
        for (let j = 0; j < topAtoms.length; j++) {
            const distance = middleAtoms[i].position.distanceTo(topAtoms[j].position);
            if (distance < a * 0.9) {
                createBond(middleAtoms[i].position, topAtoms[j].position);
            }
        }
        
        for (let j = 0; j < bottomAtoms.length; j++) {
            const distance = middleAtoms[i].position.distanceTo(bottomAtoms[j].position);
            if (distance < a * 0.9) {
                createBond(middleAtoms[i].position, bottomAtoms[j].position);
            }
        }
    }
    
    // Add coordinate axes
    createCoordinateAxes();
}

// Create coordinate axes
function createCoordinateAxes() {
    const axisLength = 3;
    const axisWidth = 0.02;
    
    // X-axis (red)
    const xAxis = new THREE.Mesh(
        new THREE.CylinderGeometry(axisWidth, axisWidth, axisLength, 8),
        new THREE.MeshBasicMaterial({ color: 0xff0000 })
    );
    xAxis.position.set(axisLength/2, 0, 0);
    xAxis.rotation.z = -Math.PI/2;
    unitCell.add(xAxis);
    
    // Y-axis (green)
    const yAxis = new THREE.Mesh(
        new THREE.CylinderGeometry(axisWidth, axisWidth, axisLength, 8),
        new THREE.MeshBasicMaterial({ color: 0x00ff00 })
    );
    yAxis.position.set(0, axisLength/2, 0);
    unitCell.add(yAxis);
    
    // Z-axis (blue)
    const zAxis = new THREE.Mesh(
        new THREE.CylinderGeometry(axisWidth, axisWidth, axisLength, 8),
        new THREE.MeshBasicMaterial({ color: 0x0000ff })
    );
    zAxis.position.set(0, 0, axisLength/2);
    zAxis.rotation.x = Math.PI/2;
    unitCell.add(zAxis);
    
    // Axis labels
    addAxisLabel('X', new THREE.Vector3(axisLength, 0, 0), 0xff0000);
    addAxisLabel('Y', new THREE.Vector3(0, axisLength, 0), 0x00ff00);
    addAxisLabel('Z', new THREE.Vector3(0, 0, axisLength), 0x0000ff);
}

// Add an axis label
function addAxisLabel(text, position, color) {
    // This is a simple representation of text using a small sphere
    // In a production environment, you might want to use TextGeometry or CSS2DRenderer
    const sphereGeometry = new THREE.SphereGeometry(0.08, 16, 16);
    const sphereMaterial = new THREE.MeshBasicMaterial({ color: color });
    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
    sphere.position.copy(position);
    unitCell.add(sphere);
}

// Create an arrow representing the loading direction
function createLoadDirectionArrow(direction, isHexagonal = false) {
    let normalizedDirection;
    
    if (isHexagonal) {
        // Convert from Miller-Bravais to Cartesian
        const cartesian = hexDirectionToCartesian(direction, 1.0, 1.63);
        normalizedDirection = normalize(cartesian);
    } else {
        normalizedDirection = normalize(direction);
    }
    
    // Scale the direction vector for visualization
    const arrowLength = 3;
    const scaledDirection = normalizedDirection.map(component => component * arrowLength);
    
    // Create arrow
    const arrowHelper = new THREE.ArrowHelper(
        new THREE.Vector3(...normalizedDirection),
        new THREE.Vector3(0, 0, 0),
        arrowLength,
        0xff0000,
        0.2,
        0.1
    );
    
    loadDirection.add(arrowHelper);
    
    // Add text to show the Miller indices
    const textPosition = new THREE.Vector3(
        scaledDirection[0],
        scaledDirection[1],
        scaledDirection[2]
    );
    
    // Like with axis labels, we represent this with a red sphere
    // In a real app you'd want to use actual text
    const sphereGeometry = new THREE.SphereGeometry(0.12, 16, 16);
    const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
    sphere.position.copy(textPosition);
    loadDirection.add(sphere);
}

// Draw a slip system (plane and direction)
function drawSlipSystem(plane, direction, structure, isHexagonal = false) {
    if (isHexagonal) {
        drawHexagonalSlipSystem(plane, direction);
    } else {
        drawCubicSlipSystem(plane, direction, structure);
    }
}

// Draw a cubic slip system
function drawCubicSlipSystem(plane, direction, structure) {
    const size = 1.8;
    const normal = normalize(plane);
    
    // Create slip plane as a semi-transparent colored plane
    const planeGeometry = new THREE.PlaneGeometry(size, size);
    const planeMaterial = new THREE.MeshBasicMaterial({
        color: 0x00ff00,
        transparent: true,
        opacity: 0.3,
        side: THREE.DoubleSide
    });
    
    const slipPlane = new THREE.Mesh(planeGeometry, planeMaterial);
    
    // Orient the plane perpendicular to its normal vector
    slipPlane.lookAt(normal[0], normal[1], normal[2]);
    
    // Position the plane to intersect the origin
    slipPlanes.add(slipPlane);
    
    // Add an outline to the plane
    const outlineGeometry = new THREE.EdgesGeometry(planeGeometry);
    const outlineMaterial = new THREE.LineBasicMaterial({ color: 0x008800 });
    const outline = new THREE.LineSegments(outlineGeometry, outlineMaterial);
    outline.lookAt(normal[0], normal[1], normal[2]);
    slipPlanes.add(outline);
    
    // Create slip direction arrow
    const normalizedDirection = normalize(direction);
    const arrowLength = 1.5;
    
    const arrowHelper = new THREE.ArrowHelper(
        new THREE.Vector3(...normalizedDirection),
        new THREE.Vector3(0, 0, 0),
        arrowLength,
        0x0000ff,
        0.1,
        0.05
    );
    
    slipDirections.add(arrowHelper);
}

// Draw a hexagonal slip system
function drawHexagonalSlipSystem(plane, direction) {
    // Convert Miller-Bravais indices to Cartesian coordinates
    const planeNormal = hexPlaneToCartesian(plane, 1.0, 1.63);
    const slipDir = hexDirectionToCartesian(direction, 1.0, 1.63);
    
    const normalizedPlaneNormal = normalize(planeNormal);
    const normalizedSlipDir = normalize(slipDir);
    
    // Draw slip plane
    const size = 1.8;
    const planeGeometry = new THREE.PlaneGeometry(size, size);
    const planeMaterial = new THREE.MeshBasicMaterial({
        color: 0x00ff00,
        transparent: true,
        opacity: 0.3,
        side: THREE.DoubleSide
    });
    
    const slipPlane = new THREE.Mesh(planeGeometry, planeMaterial);
    
    // Orient the plane perpendicular to its normal vector
    slipPlane.lookAt(
        normalizedPlaneNormal[0],
        normalizedPlaneNormal[1],
        normalizedPlaneNormal[2]
    );
    
    slipPlanes.add(slipPlane);
    
    // Add an outline to the plane
    const outlineGeometry = new THREE.EdgesGeometry(planeGeometry);
    const outlineMaterial = new THREE.LineBasicMaterial({ color: 0x008800 });
    const outline = new THREE.LineSegments(outlineGeometry, outlineMaterial);
    outline.lookAt(
        normalizedPlaneNormal[0],
        normalizedPlaneNormal[1],
        normalizedPlaneNormal[2]
    );
    slipPlanes.add(outline);
    
    // Create slip direction arrow
    const arrowLength = 1.5;
    
    const arrowHelper = new THREE.ArrowHelper(
        new THREE.Vector3(...normalizedSlipDir),
        new THREE.Vector3(0, 0, 0),
        arrowLength,
        0x0000ff,
        0.1,
        0.05
    );
    
    slipDirections.add(arrowHelper);
}
</script>